//https://gcc.godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAKxAEZSBnVAV2OUxAHIBSAJgGY8AMwB2WIQGoAQgE0AKtgDKAfQAS3AAwBBPv3F4RmafKVrNO7bv2GJAWwwQAGqRkBKCVCiP3fAKwe3H14pANcg/zdzK0whAyMAGVQAd0xiZQBZZgAbAjwAByzMCEUALVIAEXcoUvcAWg9ikvCJStcoywFrIwBhLW7VbGV4gEkAOUHFYZLsDwA2ABZ3AHoliSy8AGskvHRaojzULNRgAE8QCW6AQ2QEI3WbBjwALw5NAE4FqM6YuIl42iGY0G5VGHl6/UGI3Gykm0yWjxeqCEEHQLAARoUwhIVhIEMk7JcRCcJKjmBjMAwJAYJJc1nFzDj1lsdntUAcjqdzopnpgvnofjZ/gBpPAhfi8PldC59AZDAGwmYQYWigBUtA0vHmS14bQ6/NiNnBsvivBhU0VvF8szVGq1OslAp6Msh/DN0w8/Btmq9dt1Whx%2BAAbjtMOgJGjibxw5hkJdmAwjCkJElUCICNGaeSJEQJLEslk/rQJGhbAVMARMFlidsCHjmOna8RkgZgAzVvGYtkJIHLllmBSJCwCO1/atLnkmwAPPC2S4VuwGGfMWwSETLtGpQeSe4D/7F663XGXBhtjxCEjZhB4SmxvLXQgnVwQWzUneU2yYQkEyc0hhMZB4HOeCBn60QGgktBQoMoJQMqUg%2BksAAcrhLAsoHaDivAaPMiEOuBhbKCCYLOnKbrYPCPJIii6KYssqx4kkBJEiSNEDtSe6xjcvJ6lKJqETBRqQqaCoUYiyKkuSWI4gxTHEhJhSUuxRacbceG/PErpERAglDK6IkIpgVHyZgUn0fis7McZikiIW%2B5cSOOIGVul5GBiqDIBs2aoLmhCDjYs4EMQeA/kpak2OkWiOMoUh7lARwiMArgMAAjsQBBKgCIJhKevZ4MANk5ipdz0jxjrSLFiQpGkmQ5PkhQQBFUUxfQBFQfx2UYas8waBIfgSIhvX8OU3BDRIGikB43Uqt1g3dBIWE4eho5eT56b8ASgXBRSYVGI10X8LFEDxYlKVpRl/FLPwHU6N8%2BFSAdRZKskqQZNkuRlg1kX7f8E3/IC0JZUtYG/Ht90mg0x1Jal6V8SCl3XcDNhg1GT1Va9tUfaDB28BNYO0AjpX4VjGkQ6mJ3Q0qmmjPDoG3b8YPrajL01e99XE/wuPYwTy05rE6ZRgFQXsCehMg19Ui8IdkOnTDmXUzqtP6vTkuPZVzNvXVRSgyrv0Am1gMjoju3i5LKNHWTUNnbD8sI3TSOmx4avVRrmMmyauMq9zRsSNrJNxRbMuUxdCs7dIkuM076Os1rbsc2HJpe3bRgAErYAA4jCJQejq2JmYxFnEhGFbWTSEjEJgwDXhWxCG0nZcV1pqcZ6UomGeJrGmbi5mEnJrGKZStLl5XDDV6HQ8AGIwU3met1RQhHHOncyQXuYLwQ/el0PVepLX/CYGIwiG3qwhiDEEgAGpaMnydaDIagAAr36Hl/X7fD9P5Yx8iMgfZYLNI/4DTAAOgQCNbAfIDA/2YH/Ea3QAF4FQCAsBEDv6/yMLAgB6w0RIP4OAr%2BUCYH8G6Agke5dLi2GQfgtBs1jwJjSjgvBFgtAiHIRSO87AJDAAoZYAA7FIcw8YWyrlYQwdhRgAEjX4Z/LQFZSxZDnOgohBATh5H3qw1cy5KFaDRKgQ4VIGD32esQAA8kIOQKYPBrhXCIHwfD2hvHLgQVgNkIA2TAWNIIsw%2BCzAaG4oaI1ygeN6jw7o3AQm%2BN6rwHxriJD1Hxj4fxo0NDZX4FInQPDhoYRVCqCQAABRxziXISAYLOfMFJ0xWI3MQQa4DRqTgmrYF2hRnKXGIMAeaEgVRLHMLIgoCjZrKNUSwj8GiKG4PMFYsuLAxAAFU8gs01q45cEh6mjLsE0kywS0kSB2b%2BOh6VGkY0xJI8wuz65OOIC4iAP4%2BAhEOdHWJEh8bYnWUczZOT7maxObwzJTDenyIrLAwZaiRmVkwGMxhBgdzFJ5ModMQ9uQvAgLYkIBTLkeGni3AyVEwW2BSSEMJvyGTZNOTk3JP9aHdhjKSvJaIgpn3PjGIgQUXhhmBRNVRxBzzEFsJSNkqQgKphLp8ssEhcX73XjSdMqZ2A0sEQlC%2BTKLzYEnBWEQjwhW5ibCuYAyBkATQTEYWsRgSx5DwIUapqJkA0sDNSohxl3GXFIGiUg1rUnFiAYGSJ/DRqXE9Z08MnrvlaADca0ZVTnK4pLmG21yB9H12AIi3kRDcVgORZ07p2h/kKKBSokFRhU3jO0KQ5gyB0yxqiHYz%2BbxcUSGUMoOcm00T1kwPWhosbmXKCchATFTQsTdkkbnKlZaSDPEFTZJEYrCi8vsfYqFvw0DqvTKmqJg5OVzhINwXw/DfCBIgAZOFVJ3CLpHls2dGg3i0NSOlPAs0E1JtgYW7A6bvHeMibwRlI6WWhineCwc9ZnJbxHpua4wsTy8HtKk89DjyyFMDFuqQeAt3DSg9Wwlc6RDQpXT4/lxAN0123chjwB70x4BRdBq9Z1b2wPvTyR90602eLfXwD9Srv1hlrUOQDFdt7VNAxScDkG0nvHeGimy8Ht1Id3cGkTGTK0obSUsEl2gA25OYCIBB4mYx5BpbkuleAz4zI06mFpw76PgsdWIX9K4DgGGrpSOVCY2XeRHiQIwrS8MnEpDmfjf5h3Wb5dUx4CVmmpgHMeVcmBQw/q6T08FfTAVKLzcMgtDGi1aHU5p4dOneHCYvRWlNaXsA5IHahiwNbp05J02V9DNWskql0/ps%2BWh8zuQUZSAyKpsXIlxe4QkYZcr5UUqRtM3laQ6PU%2BgVpJxahol8hNsQ03dN3jwzZvI2Bp0SokLZtMm4fPEE8x4Hb1c/SqZW%2BQmFLxw2bknVGqkNkTgsGqeXBgGsFXHZ3ipsl52VwLam8QYk5xDFVWcgQFME1KwJiKRuBAlxgwXmvBISbjp0C6bExIOQh4PvVMe8wYpdYshhiEOXTAE1UQiDAJwdMRwoeEFJZmmR8WAXJu6MClL1mtGBlQDsHJvYG35iOMgCAuLsnbfW5ttMBrYXpgMlLl4h6/vTbaFW8rKo8ji/BVtgJHgReuFKYLqABlXBdcoj16dQQQiK4B7UfGMmL3CAgGrjXH40yDRQ4E0YMz4jxGV3lt47x2AHdmrAljQhLjmp/TmfX7l30h6IcRnkxvuvC/N0sdUmpg9EJYxIEU/CINx7mvvdAWQ7f%2B4vZgac6Vkml/Q9WrnPPtvpD/drp3G3NdplL63iX6Ztcp/BSqJ8UBmB2byIFOFrh5nN%2BCB4K3M34mROicPtMo%2B0gECfBIAAfjP6Z/259hDaHVmDFybKT7GcJuT9XGv0skFcLIyBsgKLDHedAWAwwGRpT59Y%2BUilF5WrSIqdINg/WNI9eYYABgUx4V4CU9O5gJG%2B4d%2B98lw6ASa%2B60ul2JkYSfuOISBzmBIGwRgvkIqoWkgf0%2BsMEz%2BgCiU9iTk2uTYk2cyCyH0surUQI7UpeOIs4%2BBxSrA4iPI8aIgqA6YtIBwIOk6YOqAE0cO3OYBB4RqeGDAUBrY1aDuNBuChYbUowNuC%2Bb614wOqQpi5iqAqBLwBMZebwNBwQ2upBrBIIpe6O7%2BNWF%2B/oymIaZKFKfmPYB2lwJwumeYRgnhnmIC6uV%2BBmkgn6zKPIA2XhJwE0HYl4iOOYcR4Ryqqq%2B8Gq6qYqx45qPhX2EgMyCYlI6AJwwyeAcavYguj%2BNIX%2BhgYYH49gAOQCGOh4I8rS0qkgYaHm3h8aCw4YJwxcVReUNRNKTARSHao6Tw46%2B4NkG4SOTm92pcRwbIWqqAK4PUOYBkyKSwsaowyKNKEAAS2usawwYgxhRQWIBxo0Bkn6yKp2OSYa5cs4i4CqAhWmX6kR1mEqA85cawuiqiqOuRxOKx6B1xxu2x6a%2BxiSgSDxigBArRL6kJ9ctgxx6ApxIJ10AawgEguO6yp6ixeQyxK4tIBgWAP4tYc4/BghryDyk6YJtxWJLAOJ1Ovxl4dBwACARSsQxAp6xJFeA46muQBYvkZCXEA8VJmszk8wwx3k3KpcwA%2B8qQpRPxSxgJK4LRaUK0ReIANKQgI82AVmtBO%2BDBGy%2B6sJaUE0tJB%2BBKAJJAEA1Glxppw47qdpc0OpBAepqO7qtytyZGQ6Op6peJQ6mJapw4lo2xbu2u40q43keJNKImF6TAH4tYLYEA58CGUmlQwaAa3KtpXq2u58nqMYyJtplpVIuZ8e%2BZRxJxReJZXpwQwEdE/mMZuRcZ5hKx5YihKZQCc4gYEAwY%2BK2pNpdpgS%2BZDxRZfZg6zpYqYgg6tZiGDZDx4eGmCqAZOImJRefgYZFxgSkZAhSpOWrhvUF67wCZ7ZyZ%2BZc4xZlpMBWaTOOaRC7hlIT65gD53YnROR6SaSE4ghTKoYWpde2m5mEKNIB2pecBtgD67qOIq4oOeaIs5WYFSan6g6OIE6kgBW3QT6cFcZ8FaB4FPITeZ%2BQ6qF1m8xdRJA75x5uFiFMYBFyFqwxF6FmFpF4K5F1BuFiBHpIQKFzkjFRWwqLFAO56OF8u6Ytg7pSFkFqwtaPJP4SQtw3xYxLKkxReWF%2BW0hHyp%2BdF223Ou21SOYMxxOUW/x5WSmZKTWkgLWFR/RNkd2tpkgFe286A5whlA4hwYYARXR2O7gsWde0hdg4Kll7kpxh6eFLwBFvu0GDupYBFEgYAYA2unu3uKKWqUWz4p%2BNZThLZ0VzevqWQ/OrWQu3iHmQCeQDSSaBFE0OkbUCoV5aGTheQZI6wyAf5Jlouem1%2B0Ft206JctIsaGaGG0KcBtJxYQqPefC5yhSCKdGhWFmuCuxnpmVF6pltKHVig5YHWfBOYNl3VHga504wGTlKVrlhOr50R2ldmqQ3lDO7woBVRBucBRumB0GoViigSDhfu7wL1n6budgSaWxMYOxtV5Wn15VOVgSsYCBSBKBL1QNWV1FyAMV2uL1BF/1yAgNNeF6YlYg31VhRiUciyL15pANNxGNbwtgHFP1yNf69QL1pNdRgVQuVNeKNei1bwy1uSP26BEg5wxFd21IMab5/Vdeb5wVMuieZ6aGmNp%2BP1iV8QpN5RQVj1h%2Bte5WHlJwL6KuWV0tCVXuctytrNG%2BatuxmtR59uyI2VK4cVOtSVWyR1aV4VM5rNKt7w7N5lnV9lO1PlwlraYtSKx6o1tt6OtNC1RKS1bVbtvNO11IZFAOQt3th6BkBF6aJ6Y1qKsG6KTNjtodbN4dHVDFMYAWcdlFIlwJMYydAdmBE1Gd8NWd9irtedPFBdfNNkMdJwXtxdPtpdCN4K5dS6gd6dLd8NtFIdddudoREgxxDVDYh4Ml9iqm6OMaBdMlRd8ZaBlZKJcBMl/tfdld6OMlqN6NI91a9d49C5Tx7SAZwZ92JJK95haB0JDpvdp6u9A9dg4ldqBKrNJ9Z8k9AGfVs91a89r9y97dq9Jdo5Jxm9p8k429z941e90DKotJtdx9Y9Z8TkYhWOOBQioDd9Jdz%2BT9qdVdLdHFKDrVDWgDZlHVyR7GNIeqAmc9ZK6O6O/9BUWOqAjwuQJmeApAjDVI6Y2w%2BYI1aYi5hdtpSDxNWIOY4jw1tyw6gNsStulD119umGvwvFs14Cq63ZotR6EtwNF6lGN6d6X1Bdr6q6LGat/mvmfKAGk6f2gmsNptR%2BhSxVEmiGyGLN2d86NgKdZmM1QFb6Ojm9sDqdFGf416tpJj8N2hFjEGVjfVNj/6bR4YO%2BjjpN6ObjaZnj%2Bt2dA1vw2GUqujZGT1ktl6ETVG0TfB5jPiljgtSTXG9jaTLGTjZhmTB2JV2T0muT%2BTvjAdhTF5ITwjcDH1hjFTxjNGL1sTtT8T9T9DfmjTkgDjLTGTr9xVOmkmOTH1Tt1aIu0YlcIghD/dx%2BC%2B6zCGGgWzwS2dezReRzL9JzRVHTGzUgGxbQ3Tn9eT/5bqGFRWOSG4BzIJwzRD6OjzxAQa26Fz7zVz9iGjEKOSRegLfj9zhSoL4LLzPIIJlzztpt5WhTuG%2BGCGRGxTKKmTN6GV2dfjeL66zKhLu6CeJdPpSL8DazZLZDtWeWzhVD49E4dmlIilK0aA9Yg6d2QYIYYYEYxSYiJ47qu5ReBYF4888Y7JXt2aiW3QL53QqYjpjCt1PLaYPZmrHeq63QEV1a2Zm9P1FzTpd63QQCrzM5lhdZ6EZhgrPeWe8etrF5PpBe2eLGMmi1TCztAgReh80iECog4gPsWgcgycwwUUqgj8ocEUMbcb78I4KWoi1wRgXClaaS8q7SGbYixSBAnFu8Uo98Wg5QTgVQQYygqISQhz1bpA1hAMowxu50ZBKoHbNhmh8S2ofoOIxio%2Btg5wxcMuNYNwLYE0YaG4RwjEqIFIruKYxAnkX5aIlwGI75Kw3sFbVb3gDQJGrg88uixAXgKE1EjVJkLbwIbbXb17/Ed7esPbNuYQ/bZbZUu75QYwac2YxA/YDkqwowJmdREaSTQg6mZammqljOcid5rOt5arD57iGrWrE0L5beEK5gGHQT6Uhrjp3Q2H4yxrcundPD6Bh6VApr5W6OnrN6pAlH/rvyqrLOzHsCSHahKHkuxY8ifmhHjCfj2H2juHWrsCfHQLb66QJHh6ZHcBDHJtLj6K6QXZdHDHjhodnLIRZ8MJbmfLvY/YfKkgtIKUzArSRggswU8xvVb5E0yc%2BI6QlwVAF4xixAWANcX2DOrH95PHlIfHz53nPsc4QUk4ub5gX5FYZav5MLb5onRWp1Nch%2BCF01XF9FkaO1nKUySQbFJdpjbqyX7t/jPzmjlI6XTYmXkt8doloNhF3FXV4KxXm4pXzF9RFFYDndOXw9eX%2Bd3zTFJX%2BI0dAlLXeDbXpDkl%2BXd2EWFBQivXZXBjFXb92NH9o9XLzWBV7W0Ftle1jlzlJOfKJ1VjXlt9t19NBVujj18nN1xVCtQunWSt2zvyDVGIpRLVLtaDkgkddXln/muDQ1kjxzcGbjkjbLYdy3kga1kqTkW1Yjm3B123UWu37lgtB3uDt1V3p3iepTBjZNSaP171z1MTSNf1yDytmNVXP1ENyAHF0NSarTINGLNFYNv1%2BF4KB981ozZN79cauNaMjB9UhN8jJNxPZNFNBPTPK4NNEFbPx3BuTNNPX9bVnNGD7Rh45nqyRAsJBYlSN224cQlIuD9nm0k4aPJhGPLZqPt3s6Oz5W%2BvQXxt/CAbL3IPY3UdNkg8yQSwaAfYtgNk33aBrzQLf31dSX0LqDjv73vKn3pX7vhwy4Nk/XzXt9D1ovdzzLJzmdR95DK149XXhd1IrvSQUfnv3vKjQ3CddPQuoTAfg9ZfQPOdofjdcazdm8bvHvMfTX5FPvJdVx9PtgyfadqfQ9s1HzS3mfP9IgU9RSAD5WQDJzi9caIDxfP3yARZUDJJFfyL6K%2B9RPQ/IfI/kgZ9S5F9zJV98/WXndD9cJa/KfhSWN6AEl2/Gf7V49v95aS90DfD%2BSwD0DCf994Ky/aBW9/vdfrH0QZb9g%2BD/N2oryKSTcFU/NZXoFws4d9O6BDX3MQzsAjd7%2Bp/aTgt27o99N6UndMJR0AHncxm%2ByKJpM1J41MJAVAKpi8E/QO1Bee9FUO1ynwhAqAXjGFnagI5FYcOPZPAeRwIHkYymLDS7gQB7LEk6BPdHhpR1l4UsA66FXzkJ14H/98BVAy/mz2EEdMdG4g7vraXo79k6q2dFfknT4Gyc1B4TUgZOSZrTMqBNAzAPQPUHAMmBFA6fGwJ6bVpBOPiQZsoP4GqCTezjDQWCy9ZiAk6Ug/QcDVZoCcGMQnYpioMIFMsHBJzAIsp1tLBDJBegmQfJjtwadcij/LTsygHA9g%2BwrlSQCr0%2B5q1Kq0fL3gF0c7VJnOrna8jBwSws50O3A7QC%2BWt7BRNWWQezjUO5rbZGqipDocFyIS%2Bdcs9ifNgFwN4xdNGIAEAEMNLwTD5hIworLMICILDgs7SJYVwJmEgA0%2BfuRYfAOGHbCIUsw5gWflC4DDmqQlDulgNv46CTBaBOIRXWIHlMLBtgiQSuEoHUDyBovGnhenRxUAnBZfRGtPiQxuDVanAhQZ4NEExCfBhAvwW01fpJCtB2AkIekPYHVo/G8g7gYoNhGmCiBCQ/7poJhHaCcBug6QRiLm7EljB3g/EfEPMGRNLBzgrxKum%2BHx4ZeqzE5oCKsFyMwRd3exB4KKYPCS6cnQkeimRE3pUhPfUIRkMxEB1BRXghlrELMFCCkRIglIegDREUjwR7LEcJ53Vb%2Bd9enOPygwCSDjhlApXBgA1DnAScVBpXSMnAVK6255ODue0eGVGhOjnWomAeqXnNaPDLWg6NkXNCU72t3UbAx1lICo4tlTR44BqMkPtETRKOE0JTheSdGJiwhsmIlE4VMqadJA6Qb1Nrm2TfZWkF2R4N/i0I1h2S2JM0a7h8wv5YkaIBofqPaE2j0sKPF/NaJDI%2BJJOkwt9FIDJysQYU3%2BbXM6L9x%2BiGWASK1iEEnIhieQrPKkLOSjHONxxndVweUCnE2CaMs4v2oGMXEIiWyKYlThbm1xliRAKoKQMkNCGk1sW/uTKtmJcKqY3aaAPIMSFKEhocwuOLkpWCEBNiEOzQw0XODQ7%2Bcny2gW6gmHShGjV0PYvxlsKfKrotAS4t4CuOk6TiJyd6bcWcQnJ7iXhyEggahLDHoS7Wc4ksuGLzyRj9xzjQ8eSISSBItAl4vQdeKdp3jfkOYnIRAPWp3UNoQXFaD9nLCfZXCHnP8WxwAnatzAYE8sJ2NtEsRL2KyRCbhIXFDQNxM4oiTuKdLYS2e8ktcRuKDE%2BwVJmEsMepOgzvAqJoQn6sMLZ43jnaAbZsSJONE7BtsQUNMJJKglySbSFrCMmhK3F6T5xSGCMYhPeCaSAxBEryaGNYGGSymAeLjAXl0let0xmeUJBBljyC9LJF6V1vFKnLF5KRKtViQeVyGSBwJlIYYCtBDBpgHwv42Doh1slti/KJU3IMomck%2BJhgrk09u5KSSeT48wwbySWV8lkT/JF6QKR5OCkdSupu4vyRRLMKdTYpqgoKRZJ2ZvBJpdHPRiOKyn3iKGuUt2loD/CDFKQeGMQECVKE5h0gy2EsSuHzGGBQw3mbyLDltTRh94d1NrBWGMpx0bJlKI0dVPsm7TUQtgIYQ1J9iIS%2BBrgv3MZHuyBhk4/WezjclGi0AgEGgJYBe0kg3xRg5QDIJFCyEBTByM0qkIRNCkLixpOEm0myO3KBjsZxE0ab1PGnGT6J8I0aPDMxCfT00OSAwKDPBmXBzJRkpiVmJYkPjHeerSVKUMrFc1YBRgTkriRKgCS4sFU/8a9NbE6s/KvMnvpBO7GITXW0U3SX7x9b55fA3QEQH60Py8yGosNe3j8j5AhsfxYbMNgIEgTUI2OAUUBOll0BWzoEiidVgQC4Rzg7ZjCARBsOEQfhM2HCCRGVgmGFss2nCc4ebKYTbs64s4Q3vUkfANAYGNSDwHHJGjjwVkfQx8COH3jLIXy5QPAOXEg4mYER48EgGaJc4MBeG1aKQNcC2CtJ0A5czIXVi0BZyVwOcwCMAFTC9h9G7wIzIQArnlZz4enUnA3I5bNzuOlKe%2BKkEaTzgERcgP9kPOrTjxewCYPubqPDk5THx1%2BY6atj%2BAzIt5F2RwHvJXBFi8knND%2BOLJvKSzYEuc/OVwxsj4Ab5mmCaLnMuDtyWEBYfAC/I7lZAJoE8nlC2m2yTyW0K81Kf53iAzIhhQEylI4AgVjy/MUgJYZCjUY2AwJZIEeOkDAXaAZkSocBYcLfRgKJo0C3BaumcDSB5hq6fsXF28IYJpcyCVdPfCo44hygjoS6dfQryTChYFICaJiXvlMossiOddh5FLl1zJC8zDeOXFtRfjjK3sYkg1HIB6CPAPCguX4ndwtA85vC1MLMOLnEAhFDmfgKnK3ShJq0JkuKecAMX2IqJpxF9rUGLITRLF%2BMaxdIMVhShiSwYWRaZJRBqKlF7owJNfPUUiBNFJc2ubov0VazzFynMQSYt6ihKjF4Sw3DyBfZbERA1isjLYoMhWLqA%2B%2BUOC4qoBuL5FHih%2BYXIRK%2BKlFAS7RUEsGghLDFVvWJWR0IGmLol1SnRnYtcDJLXAqS%2BJfjESUOLMl5skvr7VeoSBHAekpOq0wBkTQNg4y%2BDAlzQJzYEMvgZDBNDRBsDt08y3dIso2BzKtmddVuArhnCszNlay8MFQGjkHLyg6yk5Ssq2XVpN60cxMScumUl00QwGZ5qsoUyYDSMDANKKXj8ab11M1SbXBKEPw/LHhfyn6pKUPymVi%2BTyisM80haBJCxKsUvNCswDPNaARGbXMithXIYVQ/AdgvC0nAHB1SacboN0GUBXw04igA4olNqCBJ4gVrcoAABJMC4oQlLElpW0AjpQ0JlXwlxVyYIMa094JivOborRodKpFc8oQxoq6WGKiVRC2xX/BOVUgSFUfCQkEzMZOk96gWOCAMcym2ZIcmNHalzRNVs5EphFLNoQBOUU816trl/lWrZhs8/sF6OcbvAZFJC2pTROvoQAKF98S8W0t8HJTy8WQBMEZOcauquFcU7XDIooXuq0ZrXQ9IGGUWDKCyaNecShXXBa9pJ5IEuBWi%2BawIHUahUDGmT%2BUqgqAfyq5TdCVjIKmUvZdwPJKmXrjB0ZZOaAmodZkSQIQ6T8FDkUpjpb5ocP5fmAgDMBGAMK2tW5LQJ45BpIQCdfHglWekIxzABsp2qMB/LDg9wJQhWqlB/LbSQ6vAH8vo5DrS1IgYgO4H7VZBt15AP5SeqPUDrS1%2B6o9Q2RXVCMow%2BAF3OkVUpl5ysMpCALMrlXSq2p7qH9VIDhV3pNVgG4DV6VGhCrf1lQIdHuAFIth7EX6pZcKr/VEyANyyoDSKqNVB9kN0GgsZBtlWYbd0ggzHnsshmBIXwhzMDZ42CBQaiNgSEjiWUcjlhcgCqAUsVBfDrxoMxy1mZTQMDfqMNcK25HRuA2MbSaDuRRbfO8WqKCl/ikAFop0VOqzC14dUhiqkz0bSakOAgp8rdYUbWZ369TXCoIUlUkCAvDSReG/UbK8Nk68MFZvo13oDNKGjMgBrs3gbLCBGmFU5pI0tl0Z1SMgZBsM2XNJyZG2JNuqPUvtPJ7mwJLuvvW21VySOI9aupDVmEv1hMo5U5uJk0YeNP4BxX8oi3BSotVAy9XFtWDUDH1JebQEY08CSassW5GTX4tmFVzBFQSpjKuk8BpLaAs2VzchhaW9kkl8%2BPqPMGk3JJQIISMJHNCgA1bClKi4pbfNKWKbrBlmpzZEn8BDa6tI2pjasEUDeQySL/N4hMSk0LsGAFOKnJwmAjiIK4YeN6LEmMQShOoPsJpMSHvwHYts7G84FIJ%2BohoNgjXHJMMC%2B0e9TwWi3anoO25Alb0OYHqTFvi4hAVSNgnMKRMPVucN1ZUDYHiTC1kAit96kTA0p83OqL0W63dReqPX7q71x64dOlHbWFrJMzAEtaCrkalrPG26CTPCv/VSJ/cOOvHWYRe7drWUe5HyuzqqW46ud/UizRsDLKBI0Q3W3dIksHRi6HNkujLbRsI1wqUILaudWRLF26gBdyWoXQTp3V7rb1iOrXWYrNXC6zCVOxDDTsR23IGdu6f1BBui1iBAwOS/BbjMt2TLXA/qRmU7rwBOBJliYm3QuqDSoZtdpulsnrqJ1kBDdxWpTB2nrivYcg3BWwPzpN2Y8hdHaGtZ6rdXekh1VAwPXUG1wW7d1tOo9YHsZ1SBmdwaHEL/i6A67nGqO34ujtJ1KafNc0lsqlp%2BqAzNx8ebLa2pt3JUcQZWxLUIweI8kkdQulsg3rZBN6lGae51W3qPIL7VVfm/VXyKxk0YyNfep1iVqxnlbESi5eoWHpF1%2Ba0tuGjTUNLmjZbQtiO/LawPw2BIjdO%2BofU2HzB16zCU%2BvIBAHoBG639KUs3R3u1xd6dJve9Xf3qf0JaX9BYUfafHH2c7J9aO%2BgLPon2L7PmXOtvRklg3Hh0wbkDyPMSFBk425X8gg8GD/gSszUXOYcLqos0K7rNNM6jcRsHQ0H7NNGRzdBuE3K6etjBqXfCsK0iaetXcznV%2BtX06bDVVIe5QSgjGmq59y%2BjwKfsE2XNgD4hrVVIHhEvD29oun6kwaE3upPIG%2BrfVIA2At7OdYaqkBGtGgmH3VjyGRa7rI6GGMSJxEhRMv9UWTQ14kQg2/Ok3PzX5vYWYQPKKFGGzdFhuKd0nMMnEbDXCv4WgdQOWTMqAgZHGhSZR8h4jEB1/XqGSNlq0jp8SQB/qSNZHr6uRyNi4qQyZHCjTutgcbPDkvS/MYCmBS%2BT%2B21H/OwwBBeYB8b%2BETRhwW1OgpmQaBsFZCnxK7vqNEKfEJCpo0MekDmlouRCEjLQp8T0KERLRXINaiMWHCuhPQzdPalYjuISgTgLqa0wdwlAupsVeKqNCGWvMUBBx1HqceInkttlPkKzCUEHTxAHjQ0P3K9mhVdHMFV8zxXNvk2BKy5T89wz4ZAA9yCAP8wBRWHtVzy00rusoOMYkBzGIVqwA0GGAPnuoZkww8oA8euWoKCAHxrQLvKISzbNMjW6uTooBOfy35vhweWCb/kQn5NS85NM%2Bld0kLYTCJ8/FzLWkbzx6acc7S7y4kWcQ0wBQgJTmsgSLl58Be/Mzh2kUgdg/Ye7DmGTiNFU9AafIgOHg0KoTMdKiaIoEUDYBYiw%2BtdX5FMNUAgE5UpocJMpRaAGjlKQYwb0gV%2BZRjUw9LK0czXNIXsspzAJguGAAApCAFabGNaAJotpoLm%2Bj%2B1Bm%2BjEgZOP9N97VNRodE0Ke8vDDqbXliyjDSmds2nL2COy7A5vsuWHKllFyqQOmcl2FnXloFGZYRrLMQrskxfYFQyzp2jRAVfuOs6uIbOBJwVWBfFYSvTDErSV5Kylf4mpWBJhgMyUYMnG9wBJuVEsVlTSokDenRz45vWoyswKSk%2BVvAHJC2ek5tmJ6C5ic%2B6k3MEDtz85sc3uaVU1mOB3zfNTMCL3Frrd7zJblCo4Oob44aK6s2KgJUkAezJKslcnApVUqows5sVVyswKagZz7KzlcuZ5XoZ%2BV4YJ8yztpUbi6NUq%2BC7Bc83QaVQCqyRMquuXeCqA4yyZb6LVU2aNVQfWcqKOgx6rMZk5LvSaoCOKnYp1MtDWz3ovpQ8LjFp5KTUouAHbkr56cSBtIuSG6LVMj1VOIt7Z0cQPPYkFoBVB/aaQVmN4xATLQElIziZhNT9UVOgC01tgCNLVxdySoTM9xHjMBj8087x0TisqBnvbV1r8JIQJtd2B1mgHgg7a6vceH8JsYe1mmPtderPVDrnlo6lqeOsxnTqjVnmxy1IAXUdrXLEB1dQhtFg2AI9UOknY/tPXnqodV64gDeoPUx72wBpjpC%2BrSJQdrhx%2BmfIFufOIXSrLO7DS8EYMVX79qFlFV5tg1Fh1T663zTPnkNlXGDHVyq%2BgS6vLaHd9VrFQwbNbUHuDmMrQ1ht6sub%2BrvBuC31L6ViHeNSNfjfQeGhK60L9GsTaN3Amsb2k7GukJxvfU3CCB0cvjVRu6vsGNrRm9ApEbgIbBTry1qjdwcusNXoNW18zSvs0MVXRDIW5JXlttzWsBraVnfbenK3JaADkGi6xfqoGnXct4WgG3foGuP7K6g%2B6K6keWiSXiwrAcuLWIjzvb6On2iQN9vxC/b/thwQHRZtCGg6Vw4O7yJDrLXupYd1A%2BHYHtL1xWjAH%2BpvZjuPXY7BdcB/HUetSsG6srsWyy31j1RFqS9/ylwcwHL3M6ZpvNt/V%2Brl0YruDMunQ3Zfuusz1bEhjXc5Ykb7af0eJFPRzrN3h7BbhOxK9Hqx1HlTbyBy9BLep1S2y9du3MoVrolaCc9Hur3RPQ9swixdAe7VUHqmVs7U99t7MrodGhi6kGDlkIJHbmha3zJyhuw7HqZT76x9Jtvm2becYJXhbzexW0frMIsXbSXtvPUHYL1xnLxpduw6TeSFOGEdC675KHukPvBc7xO622TtTtKWXs1217MnszTN37bYtyM1XbrK56G7FdwJDeedtB25b5a6vVZlr2F3ObiV7mwEb/2%2BbqAnezLT3qUNkWUBqNvfdAcP0t2L0K9vdUgbgPoHUDQhn6mvuC173BLINtG1AfBQH7%2BJQuiGxLqhuI3d7vGuG8QFv2bjCtyN8aofYNNv7Ob3%2By9TrqX1f2890NkA7rbAMo3StL9xEmPsgcIHSAl9s29fbEsFGz4p6wh9kabImVVgt%2BSU/0gEI8oxUB2BVtqhUs4WGWId%2BxMDNSDEAgOtDydRebzWbG1CHDrh7YFTJ8ILmcmQ/NmTS3aT%2BL1VsK%2BRaoOntgIVFuy4qa77l99D9ZIdHHrIdC7BHJAYR/bsK0sWxBgYPQZ6hVDGOcyZj1hwo/82BJFT5/M6N1LvSqPSZYVn0jiDj378T7ujg7EI9TLboNLkjG3OiqMfCWLHwlrKflmrXtq9H3DwrXE%2BEcIZK9o3LxxSF7uaJyu3ok5oHESew04jeRjtJkMvxsSOqlDh/P0SZmpAock6ENHZm8h/bD5O8kkDGBWIHBOGWWWp009kvCCihE0XcouAqRGVQwTT%2B%2BM0/IOUlLV9YcdE08IAvQdZ7nCWeaa86WnrT1RnBXadgWFT/TTp2WfZKqdfiLRAoZMjs5DPwTfoGzs5/0ZmRBnTnwUUM4GcoU%2BEpjNCojrMZUFzO0gNiBEcdAUkNrET12apJOnwCVx9LkgT58oBEATQZSE4FjcSF5mxXysvzkF4QF0V7pIYHIdUJNo7j8N5nFuDi4fmBnIAjnjwdAP%2B0RPAy8q7psl8mleMxmrs2ueM246wKrAh2BAEdri7wy7XACrkYkDuHMUrHDgax%2BLt0CvMSAAA6n6d2M2cpXZx2Ncvt0ZSOd7VV2l8ofkeY95J%2BqpSXehouCXktxd0yTw7KbF22LHq3ixRbHUMtt7wQXi%2BvpnUCWyJUhoXQa/kVGvwh6nF2ksBGBChxXwwZGRFGThChsAycGEHICvhyB9iEGMYKmQgxONyHTALIJ0bAXYLbnNnH%2BaMo6N2CMFKb322m/hNxvPX3r31/66vhBuQ3igOQMYnviRveA0blZoiaLd%2BuUZgb4N6G/Dc1vU4lK2N/K%2BJfUu5TtBGUzS69O%2BnHnYZyMwW6WpevhgPrptwG7Lehuq3HbpQPW45bvA5KEefzXNAhffOXhOICABuytFUvB3cp%2BoL2%2BPcmR3eJLj04nOwD3xJg8QYxG20W1HvSX/bjjle5pdKacQ5cAFOdppDq4pwey%2BcBw83RlNqMhW812UxxDJxzgfbowJOkae9LPXCbpN1gtd3iu83bJ6DCh6zfdGc3GHyM%2Bm/leFvp3xb5t/O4reLuWMdb7t4LxxDivYP57gzpkRuCnVAIWYBD4G2cbYF0Apa09LJYFnnhJsdDpsFyWgwrBG3Jblt%2BW7DfJwI3LGRQOApXfEoLXAVkUTZe71zQ/tI0uRwEc1cafJy2nnGbRbf3aeGLx40aOK8iepJcGnrnAhADHfiuC3dcFK75ZHW5hLXndadUxaRwgbQryD4IBFZctQ5ytiL6MY8MTHbnIPGrgmRp50lGfiJ1%2B/6yRLqs/61Dx%2B4pgZ7vQJfVJAXucqZ79vUS6rVn8z4xJvtEXRoQB7L0y9y9qu9PnnlCYpNEM5f9JeXp1/zfmmFfDXhWkr0eJkwFPI2xD8OS2TPevuBlcH4d36dTfjviPk7yT%2BR9beUfq3LGTt8p4MHFOmEt1MdtcUT7G95OWwsV8m/N7LGDeqxhzusdFf8OZgUgbBdK8GW3e5XDy0jvR1IBi6shZyB6jCp%2Bq4RD86FMVxbtlVvKLZlaty2Wkz11rMZdl2dbZb3EqZdkGehgKdjOS7IAf5etzT6nbOEXFHWXmjMar1cjXT2Wk5V1Nby86rP1NpN70141syPMASwDs0TbdsY%2Bnk81%2BSWi4NXupdFIVhq2FcR%2BnJkf/P1H67bqsXitBr3%2BDMEER8%2B2hlOjN7xL%2BseZl%2BfHntT53W8g2bVf8een6gFh8hpFfZyC3Vr%2BkzWbCtWvsrGcmxblY0p0Ui3UJtoOhJ48crfr/wGSNFOKjTCOzASH43u/WkuqNDrDmqTZJvf7a%2BY/S4GXp4OziZ7dz9Swil4DvV3neacVaax/L27iLQAn5j%2BCvuh53kV2K7%2B0PfrjpeNWtQpEruJq3YC3Y/K4OcJgjnBoE5xc%2Bm/3wuF1cSFxO55jSlfIAseAcLCTZuxHo5sBKJbFljBxbYIPl847Dxo88Y4TUHWCwVbaJwR/vsM2NLApjWx%2B25lu6A7CZjOw3kn0Kf%2B7BfNz%2BpQvsRmH3/JhWwqYq/0OBLD9iRwJ/O/6KOHA9gJxnWlv91nNBYx/RbC%2BeIFVFNf8ERbC3/gDGikWMUGH%2BBdZZsx/87fYMXFhQAgALdZIA99GagwA%2BxBf94AxANgD0pYAPFgHoJALlFAA3/2JhovSKTwD4AljDxgcAi3wgCaMMgPQCgAiDF9g0VL/3ADiArcR79vlSgPjxSAxFUYDkA9gLmgr/QgNwC4AmjE4DQA7gMED0pBfzYDmAjgIgx%2BA8gKIChA%2BPCv8mzHgOkC3/OgNjh5A1KV4Co2Xf1xUaA3/xEDcVMQIoC1A%2BOH0DV3XpRWBtvMujD8gaM5HRxRLV304A2lLIC4BfATgFIB/FTgA0BPA1AC4AEpMiWKQnsDhF0BaATwIIAuAXwLCBXvEAF8BxoNwM4B5gTwO8DfA0gH8DOATwIYAQAcaEiCfAlwNIA4AWACQBTUCPDIAKACAFKCLUEAGABfAbqFIA8wezEoA0QKIM8C5sFhABwuAcINdQViPS2MRMMM4HyDSALAAshgAQoFaDhg743O1sgoYN5J78CE04Bugi6kSC0gzaBHZFggoKwRsgyADaU2QW%2BRmDagYxHWhagAOXKBrUCMVoAiwWoFnA2AO2XKAWEXIBukaVJGWwApAGZDTgsgkII4B8YUgESCPArwImCMgycEQhZgWoB6JdUONF8AgEIbQgBcAQgAvAwgioVLAygyJH4B8YCINaCYgjYDiCEgrgGSCAQoYIyCsgnINIA8g6INcCuAXgBSDAQrgAxD8gmILFNiTeYCAA%3D

#ifndef BYTES_H
#define BYTES_H

#define mod(X,Y) ((((X) % (Y)) + (Y)) % Y)
#define Lower_Multiple(SZ,D) ((SZ) - ((SZ) % D))

#define CACHE_LINE_SIZE (64) // likwid-topology: Cache line size:	64
#define L1_LINE_DN (CACHE_LINE_SIZE/sizeof(double)) // how many doubles in a line
// likwid-topology: Size
#define L1KiB 32
#define CACHE_L1_SIZE (L1KiB*1024/2)
#define CACHE_L2_SIZE (256*1024/2)
#define CACHE_L3_SIZE (3*1024*1024/2)
// divided by 2 because we wont be able to fill L1 completely without throwing
// useful values out

// aproximate minimum number of lines L1 cache has
// (for this capacity)(min lines mean max associativ)
#define L1LINE_N ((L1KiB*1024/8)/64)

// 2048
#define L1_DN (CACHE_L1_SIZE/sizeof(double)) // how many doubles in L1 cache
#define L2_DN (CACHE_L2_SIZE/sizeof(double)) // how many doubles in L1 cache
#define L3_DN (CACHE_L3_SIZE/sizeof(double)) // how many doubles in L1 cache

// size of the block to fit one matrix in L1
#define MAX_BL1 ((long)sqrt(L1_DN))
// align to cache line
#define BL1 (Lower_Multiple(MAX_BL1, L1_LINE_DN))
// 40 % 8 == 0, (40*40 < 2048)

// to fit 3 matrixes
#define MAX_B3L1 ((long)sqrt(L1_DN/3))
#define B3L1 (Lower_Multiple(MAX_B3L1, L1_LINE_DN))

#define MAX_B3L2 ((long)sqrt(L2_DN/3))
#define B3L2 (Lower_Multiple(MAX_B3L2, B3L1))

#define MAX_B3L3 ((long)sqrt(L3_DN/3))
#define B3L3 (Lower_Multiple(MAX_B3L3, B3L2))

// to fit 2 matrices
#define MAX_B2L1 ((long)sqrt(L1_DN/2))
#define B2L1 (Lower_Multiple(MAX_B2L1, L1_LINE_DN))

#define MAX_B2L2 ((long)sqrt(L2_DN/2))
#define B2L2 (Lower_Multiple(MAX_B2L2, B2L1))

#define MAX_B2L3 ((long)sqrt(L3_DN/2))
#define B2L3 (Lower_Multiple(MAX_B2L3, B2L2))

#define REG_SZ (32) // how many bytes in a register

#define regDN (REG_SZ/sizeof(double)) // how many doubles is a register
#define regFN (REG_SZ/sizeof(float)) // how many floats is a register

#endif


#ifndef VARRAY_HPP
#define VARRAY_HPP

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <assert.h>

namespace gm
{
using namespace std;

template <typename num>
bool isPowerOfTwo (num n) {
	return (n > 0) && ((n == 0) || ((n & (n - 1)) == 0));
}
/** @return the smallest number >= x, multiple of arg 2 */
template <typename num>
num roundUpMultiple(num x, num multiple) {
    assert(multiple);
    return ((x + multiple - 1) / multiple) * multiple;
}

template<typename elem>
inline size_t regSize() { return (REG_SZ/sizeof(elem)); }

/**
 * @class vec
 * @brief Vectorized type, performs operations in multiple elements at once
 * using Vector Extensions from gcc, see the compiler doc
 * vec<double> a,b,c; c.v += a.v * b.v;
 * the number of elems in the vec is regSize<elem>() */
template<typename elem>
struct vec
{
	elem __attribute__ ((vector_size (REG_SZ)))  v; // vectorization of elems

	inline const elem& operator[] (size_t i) const {
		assert(i < regSize<elem>() && "Vectorized elem out of register access");
		return v[i];
	}
	inline elem& operator[] (size_t i) {
		assert(i < regSize<elem>() && "Vectorized elem out of register access");
		return v[i];
	}
};
/**
 * @union vecp
 * @brief Union of a vec<elem> and elem pointers
 * used to store arrays to access vec elems or single ones as needed */
template<typename elem>
union vecp
{
	vec<elem>*  v;
	elem* p;
};

/**
 * @brief Allocates size*sizeof(elem) and aligns it into a boundary-bit boundary
 * @param ppElement pointer to array (pointer)
 * @param size number of elems in your resulting pointer
 * @param boundary : Power of two, else the behavior is undefined
 * @return The pointer you should free, don't lose it
 */
template<typename elem>
void* al_allloc(elem** ppElement, size_t size, size_t boundary){
	*ppElement = (elem*)malloc((size)*sizeof(elem) + boundary-1);
	if(*ppElement == NULL){
		cerr <<"failed to malloc "<< (size)*sizeof(elem)/1024 <<" KiB"<< endl;
		exit(0);
	}
	void* pMem = *ppElement;
	*ppElement = (elem*)(((uintptr_t)pMem + (boundary-1)) & (uintptr_t)( ~ (boundary-1)));
	return pMem;
}
/**
 * @brief Calculated padded size
 * to align the end to a cache line and avoid cache trashing
 */
size_t calcPadSize(size_t size){
	// add to make it multiple of L1_LINE_DN (padding)
	size = roundUpMultiple(size, L1_LINE_DN);
	// make sure size is not a power of two, avoid cache trashing
	if(size > L1LINE_N-1 && isPowerOfTwo(size))
		size += L1_LINE_DN;
	return size;
}
/**
 * @class varray
 * @file varray.hpp
 * @brief Vectorized array, use this to use Vector Extensions easily
 * Uses dynamic allocated aligned memory. The start of the array is 64 bytes aligned
 * so the vectorization can be used in a loop from 0 to size()/vecN()
 * (== vecInd(size()) == sizeVec())
 * the remaining non vectorized elements are looped
 * from sizeVec()*vecN() (== remStart() == remInd(sizeVec()))
 * if you must loop from a index that is not multiple of vecN()
 * you must loop through the first indexes until it reaches a multiple of 4
 * so for a generic loop from start to end:
 * fstEnd = roundUpMultiple(start, vecN());
 * for(i = start; i < fstEnd; ++i) // fsrt loop // if start%vecN == 0, no loop
 * 		something(V[i]);
 * for(iv = V.vecInd(i); iv < V.vecInd(end); ++iv) // vec loop
 * 		something(V.atv(vi));
 * for(i = V.remInd(vi); i < end; ++i) // remaining loop // if end%vecN == 0, no loop
 * 		something(V.at(i));
 */
template<class elem>
class varray
{
protected:
	vecp<elem> arr;
	size_t mSize; //  n of types
	size_t mSizeVec; // n of vec<elem>s

	size_t mSizeMem; // n of elem in memory
	size_t mSizeVecMem; // n of vec<elem>s in memory
	size_t mPad; // n of vec<elem>s in memory

	size_t mEndVec; // elem index where vectorization ends
	void* mpMem; // pointer to be freed
	/** @brief Allocates n elems (if existed: frees old varray pointer) */
	void memAlloc(size_t mSizeMem){
		if(mpMem != NULL) { free(mpMem); }
		mpMem = al_allloc(&arr.p, mSizeMem, CACHE_LINE_SIZE);
	}
public:
	/** @brief n of elems in a vec */
	inline size_t vecN() const { return regSize<elem>(); }
	/** @brief Sets size to n elems (if existed: frees old varray pointer) */
	void alloc(size_t size){
		mSize = size;
		mSizeVec = mSize/vecN();
		mSizeMem = calcPadSize(mSize);
		mSizeVecMem = mSizeMem/vecN();
		mEndVec = Lower_Multiple(mSize, vecN());
		mPad = mSizeMem - mSize;
		memAlloc(mSizeMem);
	}
	/** @param size : n of elems in the varray */
	varray(size_t size) {
		mpMem = NULL;
		alloc(size);
	}
	varray() {
		mpMem = NULL;
	}
	~varray(){
		if(mpMem != NULL) { free(mpMem); }
	}
	/** @brief n of elems */
	size_t size() const { return mSize; }
	/** @brief n of elems in memory */
	size_t sizeMem() const { return mSizeMem; }
	/** @brief n of vec elems */
	size_t sizeVec() const { return mSizeVec; }
	/** @brief n of vec elems in memory*/
	size_t sizeVecMem() const { return mSizeVecMem; }
	/** @brief Input the index
	 * @return the vec index */
	size_t vecInd(size_t index) const { return index/vecN(); }
	/** @brief remaining loop start index */
	size_t remStart() const { return mEndVec; }
	/** @brief Input vec index
	 * @return index */
	size_t remInd(size_t index) const { return index*vecN(); }
	/** @brief size of the padding */
	size_t pad() const { return mPad; }
	/**
	 * @brief Vectorized access
	 * @return return vec in the position i,
	 * it will contain elems (i*vecN()) to (i*vecN() + vecN() -1)
	 */
	inline vec<elem>& atv(size_t i) {
		assert(i < mSizeVec && "varray vec access out of bounds");
		return arr.v[i];
	}
	inline const vec<elem> & atv(size_t i) const {
		assert(i < mSizeVec && "varray vec access out of bounds");
		return arr.v[i];
	}

	inline elem& at(size_t i){
		assert(i < mSize && "varray access out of bounds");
		return arr.p[i];
	}
	inline const elem& at(size_t i) const {
		assert(i < mSize && "varray access out of bounds");
		return arr.p[i];
	}

	elem* begin() const { return &arr.p[0]; }
	elem* end() const { return &arr.p[size()]; }

	vec<elem>* beginVec() const { return &arr.v[0]; }
	vec<elem>* endVec() const { return &arr.v[sizeVec()]; }

	elem& operator[] (size_t i) {return at(i); }
	const elem& operator[] (size_t i) const { return at(i); }
};

/** @brief prints vector to cout; elems divided by spaces; no endl or flush */
template<class Cont>
void printv(Cont& C){
	for(size_t i = 0; i < C.size(); ++i)
		cout << C.at(i) <<" ";
}


}
#endif


#ifndef MATRIX_HPP
#define MATRIX_HPP

namespace gm
{
using namespace std;

#define PAD(X) (div_down((X),L1_LINE_DN)*(L1_LINE_DN*(L1_LINE_DN-1))/2)
// Optm: test switching, the below doesnt work probably
//#define PAD(X) ((size_t)floor((X)/(double)L1_LINE_DN)*(L1_LINE_DN*(L1_LINE_DN-1))/2)

#define PADDING true

// Non member access functions

template<template<class> class Cont, class Elem>
Elem& at(Cont<Elem>& C, size_t i, size_t j){
	return C.at(i,j);
}
template<template<class> class Cont, class Elem>
const Elem& at(Cont<Elem> const& M, size_t i, size_t j){
	return M.at(i,j);
}

/**
 * @brief Stores values of a square matrix in a varray, Row Major Order
 */
template<class Elem>
class Matrix
{
protected:
	varray<Elem> varr;
	size_t mSize; // n of elems per row
	size_t mSizeVec; // n of vec<elem>s per row

	size_t mSizeMem; // n of elems per row in memory
	size_t mSizeVecMem; // n of vec<elem>s per row in memory
	size_t mPad; // n of elems as padding per row

	size_t mEndVec;
	/** @brief Allocates n elems (if existed: frees old varray pointer) */
	void memAlloc(size_t size){
		varr.alloc(size*size);
	}
public:
	/** @brief n of elems in a vec */
	size_t vecN() { return varr.vecN(); }
	/** @brief Sets size to n elems (if existed: frees old varray pointer) */
	void alloc(size_t size){
		mSize = size;
		mSizeVec = mSize/vecN();
		mSizeMem = calcPadSize(mSize);
		mSizeVecMem = mSizeMem/vecN();
		mEndVec = Lower_Multiple(mSize, vecN());
		mPad = mSizeMem - mSize;
		memAlloc(mSizeMem);
	}
	/** @param size of the matrix, total number of lines */
	Matrix(size_t size){
		alloc(size);
	}

	Matrix(){}

	/** @brief n of elems in a row/column */
	size_t size() const { return mSize; }
	/** @brief n of elems in a row/column in memory */
	size_t sizeMem() const { return mSizeMem; }
	/** @brief n of vec elems in a row/column */
	size_t sizeVec() const { return mSizeVec; }
	/** @brief n of vec elems in a row/column in memory*/
	size_t sizeVecMem() const { return mSizeVecMem; }
	/** @brief Input the index
	 * @return the vec index */
	size_t vecInd(size_t index) const { return index/vecN(); }
	/** @brief remaining loop start index */
	size_t remStart() const { return mEndVec; }
	/** @brief Input vec index
	 * @return index */
	size_t remInd(size_t index) const { return index*vecN(); }
	/** @brief size of the padding in the matrix */
	size_t pad(){ return mPad; }

	size_t indVecMem(size_t i, size_t j) const {
		assert(i < mSizeMem && j < mSizeVecMem);
		return i*mSizeVecMem + j;
	}
	vec<Elem>& atv(size_t i, size_t j) {
		return varr.atv(indVecMem(i,j));
	}
	const vec<Elem>& atv(size_t i, size_t j) const {
		return varr.atv(indVecMem(i,j));
	}
	size_t indMem(size_t i, size_t j) const {
		assert(i < mSizeMem && j < mSizeMem);
		return i*mSizeMem + j;
	}
	Elem& at(size_t i, size_t j){
		return varr.at(indMem(i,j));
	}
	const Elem& at(size_t i, size_t j) const {
		return varr.at(indMem(i,j));
	}
};

/**
 * @brief Stores values of matrix in a varray, Column Major Order
 */
template<class Elem>
class MatrixColMajor : public Matrix<Elem>
{
	using Matrix<Elem>::Matrix;
	using Matrix<Elem>::varr;
	using Matrix<Elem>::mSizeMem;
	using Matrix<Elem>::mSizeVecMem;
public:

	size_t indVecMem(size_t i, size_t j) const {
		assert(i < mSizeVecMem && j < mSizeMem);
		return j*mSizeVecMem + i;
	}
	vec<Elem>& atv(size_t i, size_t j) {
		return varr.atv(indVecMem(i,j));
	}
	const vec<Elem>& atv(size_t i, size_t j) const {
		return varr.atv(indVecMem(i,j));
	}
	size_t indMem(size_t i, size_t j) const {
		assert(i < mSizeMem && j < mSizeMem);
		return j*mSizeMem + i;
	}
	Elem& at(size_t i, size_t j){
		return varr.at(indMem(i,j));
	}
	const Elem& at(size_t i, size_t j) const {
		return varr.at(indMem(i,j));
	}
};

template<class Mat>
void swap_rows(Mat& M, size_t row0, size_t row1){
	if(row0 == row1)
		return;
	for(size_t j = 0; j < M.size(); j++){
		swap(M.at(row0, j), M.at(row1, j));
	}
}
/**
 * @brief M += B
 * @param sign -1 with you want to add -b
 */
template<class Mat>
void add(Mat& M, Mat& B, double sign = 1){
	for(size_t i=0; i < M.size(); i++){
		for(size_t j=0; j < M.size(); j++){
			M.at(i,j) += sign*B.at(i,j);
		}
	}
}
/**
 * @brief copy matrix A to yourself
 */
template<class Mat, class elem>
void set(Mat& M, const Matrix<elem>& A){
	for(size_t i=0; i < M.size(); i++){
		for(size_t j=0; j < M.size(); j++){
			M.at(i,j) = A.at(i,j);
		}
	}
}
/**
 * @brief sets all matrix to parameter
 */
template<class Mat>
void set(Mat& M, double x){
	for(size_t i=0; i < M.size(); i++){
		for(size_t j=0; j < M.size(); j++){
			M.at(i,j) = x;
		}
	}
}

template<class Mat>
void print(Mat& M){
	for(size_t i = 0; i < M.size(); i++){
		for(size_t j = 0; j < M.size(); j++){
			cout << M.at(i, j) <<" ";
		}
		cout << endl;
	}
}
/**
 * @brief sets I to identity
 */
template<class Mat>
void identity(Mat& I){
	for(size_t i = 0; i < I.size(); i++){
		for(size_t j = 0; j < I.size(); j++){
			I.at(i, j) = 0;
		}
		I.at(i, i) = 1;
	}
}
/**
 * @brief Assigns random matrix to M
 * @param M needs to have been allocated
 */
template<class Mat>
void randomMatrix(Mat& M){
	size_t i, j;
	double invRandMax = 1.0/(double)RAND_MAX;

	for(i = 0; i < M.size(); i++){
		for(j = 0; j < M.size(); j++){
			M.at(i,j) = (double)rand() * invRandMax;
		}
	}
}
/**
 * @brief prints matrix with size in the first line
 */
template<class Mat>
void printm(Mat& M){
	cout<<  M.size() <<"\n";
	print(M);
}


}
#endif



#include <cmath>
#include <ctgmath>

using namespace std;
using namespace gm;



//#define max(x,y) ((x) > (y) ? x : y)

enum class Direction {
	Forwards,
	Backwards,
};

enum class Diagonal {
	Unit,
	Value,
};

enum class Permute {
	True,
	False,
};


/**
 * @brief
 * @param LU
 * @param X
 * @param B
 * @param P
 */
template<Direction direction, Diagonal diagonal, Permute permute,
	class LUMatrix, class XMatrix, class BMatrix>
inline void substMLU0AU(LUMatrix& LU, XMatrix& X, BMatrix& B, varray<size_t>& P){
// Defines to index Matrices, if direction is backwards, access is reversed
#define ind(M,i,j) (direction == Direction::Forwards ? \
	M.at(i, j) : \
	M.at((size-1)-(i), (size-1)-(j)))
#define indvi(M,i,j) (direction == Direction::Forwards ? \
	M.atv(i, j) : \
	M.atv((size-1)/vn-(i), (size-1)-(j)))
#define indvj(M,i,j) (direction == Direction::Forwards ? \
	M.atv(i, j) : \
	M.atv((size-1)-(i), (size-1)/vn-(j)))

	size_t size = X.sizeMem();
	size_t i, j, k, kv;
	size_t bi[5], bj[5], bk[5];
	//size_t bimax[5], bjmax[5], bkmax[5];
	size_t imax, jmax;
	size_t bstep[5];
	size_t isrt;
	const size_t iunr = 2;
	const size_t junr = 4;
	/**/
	bstep[0] = B2L1;
	bstep[1] = bstep[0]*3;
	/* export GCC_ARGS=" -D L0=${32} -D L1M=${3}"*
	bstep[0] = L0;
	bstep[1] = bstep[0]*L1M;/**/

	for(j = 0; j < size; ++j)
		for(i = 0; i < size; ++i)
			if(permute == Permute::True)
				ind(X, i, j) = ind(B, P.at(i), j);
			else
				ind(X, i, j) = ind(B, i, j);

	size_t vn = X.vecN(); // number of doubles in vec
	vec<double> acc[iunr*junr];
#define vect(v) for(size_t v=0; v < vn; ++v) // ease vectorization
#define unrll(u,step) for(size_t u = 0; u < step; ++u) // ease unrolling
#define unr(iu,iunr,ju,junr) unrll(iu,iunr) unrll(ju,junr) // unroll 2 dimensions

	for (bi[0] = 0; bi[0] < size; bi[0] += bstep[0]) // L1 tiling
	for (bj[0] = 0; bj[0] < size; bj[0] += bstep[0]) {
		imax = min(bi[0]+bstep[0] , size); // setting tile limits
		jmax = min(bj[0]+bstep[0] , size);
		if(direction == Direction::Forwards)
			isrt = bi[0];
		else isrt = max(bi[0], X.pad());
		for (bk[0] = 0; bk[0] < (bi[0]); bk[0] += bstep[0]) {
			for (i = bi[0]; i < imax -(iunr-1); i += iunr) { // i unroll
				for (j = bj[0]; j < jmax -(junr-1); j += junr) { // j unroll
assert(((direction == Direction::Backwards) && (((size-1-bk[0])-(vn-1)) % 4 == 0))
|| ((direction == Direction::Forwards) && (bk[0] % 4 == 0))); // So that vectorization doesn't give segfault -O2
// Multiply current tile: i,j = A krow * IA kcol
// For (i,j): from i to i+iunr; from j to j+junr
#define kloop(iunr, junr)	\
					unr(iu,iunr,ju,junr) vect(v) acc[iu*junr + ju][v] = 0;	\
					/*vectorized loop*/	\
					for (kv = bk[0]/vn; kv < (bk[0]+bstep[0])/vn; ++kv)	\
						unr(iu,iunr,ju,junr)	\
						acc[iu*junr+ju].v += indvj(LU, i+iu, kv).v * indvi(X, kv, j+ju).v;	\
					unr(iu,iunr,ju,junr) /*vect result sum*/	\
					vect(v) ind(X, i+iu, j+ju) -= acc[iu*junr+ju][v];
// end define
					kloop(iunr,junr)
				}
				for (j = j; j < jmax; ++j) { // j unroll reminder
					kloop(iunr,1)
				}
			}
			for (i = i; i < imax; ++i) { // i unroll remainder
				for (j = bj[0]; j < jmax -(junr-1); j += junr) { // j unroll
					kloop(1,junr)
				}
				for (j = j; j < jmax; ++j) { // j unroll reminder
					kloop(1,1)
				}
			}
		} // Last block in K, diagonal, divide by pivot
		for (bk[0] = (bi[0]); bk[0] < (bi[0]+bstep[0]); bk[0] += bstep[0]) {
			for (i = isrt; i < imax; ++i)
			for (j = bj[0]; j < jmax; ++j) {
				for (k = bk[0]; k < i; ++k)
					ind(X, i, j) = ind(X, i, j) - ind(LU, i, k) * ind(X, k, j);
				if(diagonal == Diagonal::Value)
					ind(X, i, j) /= ind(LU, i, i);
			}
		}
	}
#undef vect
#undef unrll
#undef unr
#undef kloop
#undef ind
#undef indvi
#undef indvj
}


template<class LUMatrix, class IAMatrix, class IMatrix>
inline void solveMLU0(LUMatrix& LU, IAMatrix& X, IMatrix& B, varray<size_t>& P){
	static
	MatrixColMajor<double> Z(X.size());
	if(Z.size() != X.size()){ Z.alloc(X.size()); }
	// find Z; LZ=B
	substMLU0AU<Direction::Forwards, Diagonal::Unit, Permute::True>(LU, Z, B, P);
	// find X; Ux=Z
	substMLU0AU<Direction::Backwards, Diagonal::Value, Permute::False>(LU, X, Z, P);
}
/**
 * @brief Given a matrix A and it's inverse, calculates residue into R. \
 * Uses tiling on L0, SSE, unrolling on i,j.
 */
template<class AMatrix, class IAMatrix, class IMatrix>
inline double residue0AUIJ(AMatrix& A, IAMatrix& IA, IMatrix& R){
	size_t size = A.size();
	size_t bi[5], bj[5], bk[5];
	//size_t bimax[5], bjmax[5], bkmax[5];
	size_t bstep[5];
	/**/
	const size_t iunr = 2;
	const size_t junr = 4;
	/* export GCC_ARGS=" -D IUNRLL=${2} -D JUNRLL=${4}"* const size_t iunr = IUNRLL; const size_t junr = JUNRLL;/**/
	vec<double> acc[iunr*junr];
	/**/
	bstep[0] = B2L1;
	/* export GCC_ARGS=" -D L0=${24} -D L1M=${3}"* bstep[0] = L0; bstep[1] = bstep[0]*L1M;/**/
	size_t i, j, k, kv;
	for(j = 0; j < size; ++j){
		for(i = 0; i < j; ++i)
			R.at(i,j) = 0;
		R.at(j,j) = 1;
		for(i = j+1; i < size; ++i)
			R.at(i,j) = 0;
	}
	// Multiply A*IA and subtract from R
	size_t vn = R.vecN(); // number of elements on the register (vectorization)
#define vect(v) for(size_t v=0; v < vn; ++v) // ease vectorization
#define unrll(u,step) for(size_t u = 0; u < step; ++u) // ease unrolling
#define unr(iu,iunr,ju,junr) unrll(iu,iunr) unrll(ju,junr) // unroll 2 dimensions

	for (bi[0] = 0; bi[0] < size; bi[0] += bstep[0]) // L1 tiling
	for (bj[0] = 0; bj[0] < size; bj[0] += bstep[0])
	for (bk[0] = 0; bk[0] < size; bk[0] += bstep[0]){
		size_t imax = min(bi[0]+bstep[0], size); // setting tile limits
		size_t jmax = min(bj[0]+bstep[0], size);
		size_t kmax = min(bk[0]+bstep[0], size);
		for (i = bi[0]; i < imax -(iunr-1); i += iunr) { // i unroll
			for (j = bj[0]; j < jmax -(junr-1); j += junr) { // j unroll
// Multiply current tile: i,j = A krow * IA kcol
// For (i,j): from i to i+iunr; from j to j+junr
#define kloop(iunr, junr)	\
				unr(iu,iunr,ju,junr) vect(v) acc[iu*junr + ju][v] = 0;	\
				for (kv = bk[0]/vn; kv < kmax/vn; ++kv) /*vectorized loop*/	\
					unr(iu,iunr,ju,junr)	\
					acc[iu*junr+ju].v += A.atv(i+iu, kv).v * IA.atv(kv, j+ju).v;	\
				for(k = kv*vn; k < kmax; ++k) /*vect remainder*/	\
					unr(iu,iunr,ju,junr)	\
					R.at(i+iu, j+ju) -= A.at(i+iu, k) * IA.at(k, j+ju);	\
				unr(iu,iunr,ju,junr) /*vect result sum*/	\
				vect(v) R.at(i+iu, j+ju) -= acc[iu*junr+ju][v];
// end define
				kloop(iunr, junr)
			}
			for(j = j; j < jmax; ++j){ // j unroll reminder
				kloop(iunr,1)
			}
		}
		for (i = i; i < imax; ++i) { // i unroll remainder
			for (j = bj[0]; j < jmax -(junr-1); j += junr) { // j unroll
				kloop(1,junr)
			}
			for (j = j; j < jmax; ++j) { // j unroll reminder
				kloop(1,1)
			}
		}
	}
#undef unrll
#undef kloop
	// Calculate norm error from R
	size_t iv;
	double errNorm = 0;
	vec<double> errNormV{0};
	for(j = 0; j < size; ++j){
		for(iv = 0; iv < R.sizeVec(); ++iv) // vect loop
			errNormV.v += R.atv(iv,j).v*R.atv(iv,j).v;
		for(i = R.remStart(); i < R.size(); ++i) // vect remainder
			errNormV[R.vecN()-1] += R.at(i,j)*R.at(i,j);
	}
	vect(v) errNorm += errNormV[v]; // vect result sum

	return sqrt(errNorm);
#undef vect
}
/**
 * @brief Calculates inverse of A into IA
 * @param LU decomposition of A
 * @param IA return value, no init needed
 * @param P LU pivot permutation
 * @param iter_n
 */
template<class AMatrix, class LUMatrix, class IAMatrix>
void inverse_refining(AMatrix& A, LUMatrix& LU, IAMatrix& IA, varray<size_t>& P, size_t iter_n){
	long i=0;
	// number of digits of iter_n, for pretty printing
	long digits = (long)log10((double) iter_n) + 1;
	double c_residue;
	//double l_residue;
	size_t size = A.size();
	// Optm: iterating line by line
	MatrixColMajor<double> W(A.size()), R(A.size());

	for(size_t j = 0; j < size; ++j){
		for(size_t i = 0; i < j; ++i)
			R.at(i,j) = 0;
		R.at(j,j) = 1;
		for(size_t i = j+1; i < size; ++i)
			R.at(i,j) = 0;
	}

	//LIKWID_MARKER_START("INV");

	//solveMLU(LU, IA, R, P);
	solveMLU0(LU, IA, R, P);

	//LIKWID_MARKER_STOP("INV");
	//LIKWID_MARKER_START("RES");

	c_residue = residue0AUIJ(A, IA, R);

	//LIKWID_MARKER_STOP("RES");

	while(i < iter_n){
		// (abs(l_residue - c_residue)/c_residue > EPSILON) && (l_residue > c_residue)
		// relative approximate error
		i += 1;
		// R: residue of IA

		//solveMLU(LU, W, R, P);
		solveMLU0(LU, W, R, P);

		//LIKWID_MARKER_STOP("INV");
		// W: residues of each variable of IA
		// adjust IA with found errors
		//LIKWID_MARKER_START("SUM");
/*
		for(size_t j=0; j < IA.size(); ++j)
			for(size_t i=0; i < IA.size(); ++i)
				IA.at(i,j) += W.at(i,j);*/
		//add(IA, W);

#define unrll(u,step) for(size_t u = 0; u < step; ++u) // ease unrolling
		size_t j, junr = 1;
		for(j=0; j < IA.size() -(junr-1); j += junr){
			for(size_t i=0; i < IA.size(); ++i)
				IA.at(i,j) += W.at(i,j);
		}
		for(j = j; j < IA.size(); ++j)
			for(size_t i=0; i < IA.size(); ++i)
				IA.at(i,j) += W.at(i,j);
#undef unrll


		c_residue = residue0AUIJ(A, IA, R);

		//LIKWID_MARKER_STOP("RES");
	}
}

void testVec(size_t size){
	Matrix<double> LU(size);
	MatrixColMajor<double> B(LU.size()), X(LU.size());
	size_t i,j,kv;

    size_t step = 8;
	vec<double> acc[step];

#define vect(v) for(size_t v = 0; v < step; v++)
    vect(s)
        acc[s][0] += 4;
	for(i=0; i < size; ++i)
	for(j=0; j < size; ++j)
	for(kv=0; kv < size/4; kv += 1){
		for(size_t s = 0; s < step; ++s)
            acc[s].v += B.atv(i,kv+s).v * X.atv(kv+s,j).v;
        for(size_t o = 0; o < 4; o++)
            acc[o][0] += o;
    }

	cout << acc[0][0] << endl;
#undef vect
}

int main(int argc, char **argv) {
	size_t size = 1024;
	size_t iter_n = 20;
	Matrix<double> LU(size);
	Matrix<double> A(size);
	MatrixColMajor<double> IA(LU.size());
	varray<size_t> P(LU.size());

	inverse_refining(A, LU, IA, P, iter_n);


// to fit 2 matrices
#define MAX_B2L1 ((long)sqrt(L1_DN/2))
#define B2L1 (Lower_Multiple(MAX_B2L1, L1_LINE_DN))

#define MAX_B2L2 ((long)sqrt(L2_DN/2))
#define B2L2 (Lower_Multiple(MAX_B2L2, B2L1))

#define MAX_B2L3 ((long)sqrt(L3_DN/2))
#define B2L3 (Lower_Multiple(MAX_B2L3, B2L2))
	cout << "L1_DN";
	cout << L1_DN;
	cout << "MAX_BL1";
	cout << MAX_BL1;
	cout << "BL1";
	cout << BL1;
	cout << "MAX_B3L1";
	cout << MAX_B3L1;
	cout << "B3L1";
	cout << B3L1;
	cout << "MAX_B2L1";
	cout << MAX_B2L1;
	cout << "B2L1";
	cout << B2L1;

	cout << "B2L1";
	cout << MAX_B2L2;
	cout << "B2L1";
	cout << B2L2;
	cout << "MAX_B2L3";
	cout << MAX_B2L3;
	cout << "B2L3";
	cout << B2L3;



	//testVec(1024);
    return 0;
}
